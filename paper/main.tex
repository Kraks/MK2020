%% This is file `sample-acmlarge.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmlarge')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmlarge.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[acmlarge,review]{acmart}
\settopmatter{printfolios=true}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2020}
\acmYear{2020}
\acmDOI{10.1145/1122445.1122456}


%%
%% These commands are for a JOURNAL article.

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\usepackage{natbib}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{graphicx} 
\usepackage{xcolor}

\lstset{
  basicstyle=\ttfamily,
  mathescape,
  xleftmargin=0.2\textwidth, xrightmargin=0.2\textwidth
}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

%%
%% end of the preamble, start of the body of the document source.
\title{$\lambda$Kanren: Higher-order Logic Programming with Shallow Embedding}
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Weixi Ma}
\email{mvc@iu.edu}
\author{Kuang-chen Lu}
\email{kl13@iu.edu}
\author{Daniel P. Friedman}
\email{dfried00@gmail.com}
\affiliation{%
  \institution{Indiana University}
  \city{Bloomington}
  \state{IN}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  We present $\lambda$Kanren, a new member of the Kanren
family~\citep{friedman_reasoned_2018}
that is inspired by $\lambda$Prolog~\citep{miller_programming_2012}.
With a shallow embedding implementation, the term language of $\lambda$Kanren
is represented by the functions and macros of its host language. As a
higher-order logic programming language, $\lambda$Kanren is extended with
a subset of higher-order hereditary Harrop formulas~\citep{miller_uniform_1991}.
%Excluding the higher-order unification algorithm, our system is obtainable by
%adding about 40 lines of code to the implementation from chapter 10 of
%TRS2~\citep{friedman_reasoned_2018}.
\end{abstract}
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

$\lambda$Kanren introduces four new operators to
$\mu$Kanren\citep{hemann_kanren:_2013}: \texttt{tie}, \texttt{app},
\texttt{assume-rel}, and \texttt{all}. \texttt{tie} and \texttt{app} create
binding structures (whereas in $\mu$Kanren there are only pair structures).
And the $\equiv$ operator recognizes $\alpha\beta$-conversions
between binding structures. The \texttt{assume-rel} and \texttt{all} operators
enable more expressive reasoning with Hereditary Harrop
formulas~\citep{miller_hereditary_1987}.
To demonstrate $\lambda$Kanren's increment to $\mu$Kanren, we first
review the two forms of logic behind these two languages: fohc and hohh.

$\mu$Kanren implements First-order
Horn clause (fohc)~\citep{apt_contributions_1982}. The grammar of \emph{Horn clause}
is shown in Fig~\ref{hc}. We say $\mu$Kanren is \emph{first-order}, as its
unification algorithm identifies only
structural equivalence. As an example that illustrates the correspondence
between $\mu$Kanren definitions and fohc formulas,
consider the relation \texttt{append$^o$}.

\begin{lstlisting}
  (defrel (append$^o$ xs ys zs)
    (cond$^e$
      [($\equiv$ nil xs) ($\equiv$ ys zs)]
      [(fresh (a d r)
         ($\equiv$ `(,a . ,d) xs)
         (append$^o$ d ys r)
         ($\equiv$ `(,a . ,r) zs))]))
\end{lstlisting}

\paragraph{D formulas of fohc}
In $\mu$Kanren, a \texttt{defrel} introduces a \emph{D formula}.
For example, the \texttt{append$^o$} definition corresponds to this \emph{D formula},
\begin{align*}
  \forall xs\,\forall ys\,\forall zs  & \quad (\equiv\, xs\, nil) \wedge (\equiv\, ys\, zs) \\
  & \vee \exists a\,\exists d\,\exists\,r\,(\equiv\, xs\, `(,a . ,d)) \wedge (append^o\,\, d\,\, ys\,\, r) \wedge (\equiv\, `(,a . ,r)\, zs) \\
  & \supset (append^o\,\,xs\,\, ys\,\, zs).
\end{align*}
Here \texttt{append$^o$} and $\equiv$ both build atomic formulas. For example,
$(append^o\,\,xs\,\, ys\,\, zs)$ and $(\equiv\, xs\, nil)$ are atomic formulas.


\begin{figure}[!tbp]
  \begin{tabular}{r r l l}
    Goals & $G$ & $::=$ & $A\,|\,G\wedge G\,|\,G\vee G\,|\,\exists x\,G$ \hspace{3cm} \\
    Definitions & $D$ & $::=$ & $A\,|\,G \supset D\,|\,D\wedge D\,|\,\forall x\,D $\\
    Atomic Formulas & $A$ & & \\
  \end{tabular}
  \caption{Horn Clause Formulas}\label{hc}
\end{figure}

\begin{figure}[!tbp]
  \begin{tabular}{r r l l}
    Goals & $G$ & $::=$ & ${\color{gray} A\,|\,G\wedge G\,|\,G\vee G\,|\,\exists x\,G\,}|\,D\supset G\,|\,\forall x\,G$\\
    Definitions & $D$ & $::=$ & ${\color{gray} A\,|\,G \supset D\,|\,D\wedge D\,|\,\forall x\,D }$ \hspace{3cm} \\
    Atomic Formulas & $A$ & & \\
  \end{tabular}
  \caption{Hereditary Harrop Formulas}\label{hh}
\end{figure}

\paragraph{G formulas of fohc}
In $\mu$Kanren, a \texttt{run} query contains a \emph{G formula}, e.g.,
\begin{lstlisting}
  (run 1
    (fresh (xs)
      (append$^o$ xs `(1 2) `(1 2))))
\end{lstlisting}
is formulated as
\begin{align*}
  \exists xs \,\, (append^o\,\, xs\,\, `(1\, 2)\,\, `(1\, 2)).
\end{align*}

\paragraph{Formulas of hohh}
$\lambda$Prolog implements a more expressive logic, \emph{higher-order
  hereditary Harrop formulas} (hohh)~\citep{miller_hereditary_1987}.
Shown in Figure~\ref{hh}, Hereditary Harrop formulas extend G formulas
with implicational goals and forall-quantification. Also, with higher-order
unification, the unification algorithm of $\lambda$Prolog identifies
$\alpha\beta$-equivalence between binding structures
(that are absent in $\mu$Kanren).

This paper presents $\lambda$Kanren.
$\lambda$Kanren implements implicational goals and forall-quantification with
two new operators, \texttt{assume-rel} and \texttt{all}, respectively.
Also, $\lambda$Kanren incorporates higher-order pattern
unification~\citep{miller_logic_1991} for the binding structures
(that are created by another two new operators, \texttt{tie} and \texttt{app}).

%% The \texttt{assume-rel} operator incorporates the idea of dynamic scoping
%% that is built on side-effects. For readers who are familiar with $\mu$Kanren
%% implementations, we add a global variable for the scoping and the
%% \texttt{defrel} macro accommodates with three extra lines to manipulate
%% the global variable. The \texttt{assume-rel} operator is a macro that extends
%% the global variable.

The rest of this paper demonstrates the uses these new four operators
and the implementation details when appropriate.
Our implementation of $\lambda$Kanren is available at
https://github.com/mvcccccc/MK2020.

\section{Higher-order Unification}
This section shows the power of higher-order pattern unification.
By adopting \citet{miller_logic_1991}'s unification algorithm, $\lambda$Kanren
is equipped with two new operators: \texttt{tie} and \texttt{app}.
\texttt{tie} expressions are abstractions and \texttt{app} is the
shorthand for application.
The $\equiv$ operator in $\lambda$Kanren identifies
$\alpha\beta$-equivalence between terms that involve
\texttt{tie} and \texttt{app}.

Consider the following example that demonstrates $\alpha$-equivalence.
This example, metaphorically, tests the equivalence between
\texttt{($\lambda$ (a b) (a b))} and \texttt{($\lambda$ (x y) (x y))}.

\begin{lstlisting}
> (run 1 q
    (== (tie (a b) (app a b))
        (tie (x y) (app x y))))
'(_0)
\end{lstlisting}


\texttt{tie} is implemented as the following macro. It takes a list of variable
names and a term. It then creates a \texttt{Tie} structure that is internally
used for curried binders. Hereafter, we call a variable that is introduced
by \texttt{fresh} a \emph{unification variable} and a variable that is
introduced by \texttt{tie} a \emph{binding variable}.

\begin{lstlisting}
(define-syntax tie
  (syntax-rules ()
    [(_ () t) body]
    [(_ (x$_0$ x ...) body)
     (let ([x$_0$ (Var 'x$_0$)])
       (Tie x$_0$ (tie (x ...) body)))]))
\end{lstlisting}

\texttt{app} is implemented as the following macro that elaborates a list of
terms to an \texttt{App} structure that is internally used for curried
applications.

\begin{lstlisting}
(define-syntax app
  (syntax-rules ()
    [(_ rator rand) (App rator rand)]
    [(_ rator rand$_0$ rand ...)
     (app (App rator rand$_0$) rand ...)]))
\end{lstlisting}

Next, consider the following example that queries for two instantiations
of \texttt{f}. This example demonstrates (1) $\beta$-conversions during
unification and (2) how binding structures are reified.

\begin{lstlisting}
> (run 2 f
    (== (tie (a b) (app a b))
        (tie (x y) (app f x y))))
'((tie (_0) (tie (_1) (app _0 _1))))
\end{lstlisting}

There is only one instantiation: \texttt{f} is a function of two inputs and
\texttt{f} outputs an application form that applies its first input on the
second one.

The internal structures, \texttt{Tie} and \texttt{App}, are reified as
tagged lists. These tagged lists reflect their corresponded user interfaces,
\texttt{tie} and \texttt{app}. During reification, binding variables and
unification variables are both converted to underscore-digit symbols.

The power of higher-order unification, however, comes in with limits.
To ensure decidability, $\beta$-conversion in
\citet{miller_logic_1991}'s algorithm restricts application forms:
when the operator of an \texttt{app} is a unification variable, its operands
must be distinct binding variables, otherwise unification fails.
For example, the following query has no solution because the operands of
the unification variable \texttt{f} are not distinct. In this case, with
\texttt{f} being a function of two input \texttt{b}s, we cannot decide which
\texttt{b} is used in the body of the function that instantiates \texttt{f}.
\begin{lstlisting}
> (run 1 f
    (== (tie (a) a)
        (tie (b) (app f b b))))
'()
\end{lstlisting}

To enforce this pattern restriction, \citet{miller_logic_1991}'s algorithm
imposes another restriction on variable scopes: the instantiation of a
unification variable may only contain its \emph{visible} binding variables.
A bound variable \texttt{x} is visible to a unification variable \texttt{q} if
the introduction of \texttt{x} lexically precedes that of \texttt{q}.
Given the following example, it seems that \texttt{q} can be instantiated by
\texttt{y}. Unfortunately, \texttt{y} is not visible to \texttt{q} and the
query has no solution.
\begin{lstlisting}
> (run 1 q
    (== (tie (a b) (app a b))
        (tie (x y) (app x q))))
'()
\end{lstlisting}

\section{Implicational Goals}
This section introduces the \texttt{assume-rel} operator that implements
implicational goals ($D \supset G$).
An \texttt{assume-rel} operator takes two inputs: (1) the hypothesis in
the form of a D formula and (2) the goal in the form of a G formula.
The \texttt{assume-rel} operator then uses the hypothesis as a fact and
moves on to the goal.

Implementing \texttt{assume-rel} is subtle with shallow embedding.
Because the definitions of $\lambda$Kanren are kept in the run-time environment
of its host language, extending these definitions requires updating
the run-time environment. This problem is illustrated in the following
example, liberally adapted from \citet[p.~80]{miller_programming_2012}.

\begin{lstlisting}
  (defrel (taken name class)
    (conde
      [(== 'Josh name) (== 'B521 class)]
      [(== 'Josh name) (== 'B522 class)]))
  (defrel (pl-major name)
    (taken name 'B521)
    (taken name 'B523)
    (taken name 'B522))
\end{lstlisting}

One may complete \texttt{pl-major} after taking three classes: \texttt{B521},
\texttt{B522}, and \texttt{B523}. And Josh currently has \texttt{taken}
\texttt{B521} and \texttt{B522}. In the following query, the \texttt{assume-rel}
operator extends the definition of \texttt{taken} with \texttt{(taken 'Josh q)}
and then moves on to the goal \texttt{(pl-major 'Josh)}.

\begin{lstlisting}
  > (run 1 q
  (assume-rel [(taken name class)
                    (== 'Josh n)
                    (== 'q class)]
        (pl-major 'Josh)))
  '(B523)
\end{lstlisting}

From the implementation aspect, because the host language is lexically scoped,
the definition of \texttt{pl-major} is fixed. This means that, the free variable
in \texttt{pl-major}, namely \texttt{taken}, always uses the
original definition of Josh taking \texttt{B521} and \texttt{B522}. 
To extend definitions on the fly, we need to create dynamic scope so that the
free variables may use the latest, updated definitions.

Our approach is to add an extra layer between $\lambda$Kanren and the host
language (Racket). This extra layer redirects function definitions.

We introduce two global containers,
\texttt{name->idx} and \texttt{idx->def}. Each \texttt{defrel} extends these
two containers by creating a new index, putting the name-idx pair and the
idx-def pair in the two containers respectively.
The \texttt{idx->def} container is global. And the \texttt{name->idx}
container is threaded through during the execution of
a query (an invocation of a \texttt{run}).

To invoke a definition, one follows \texttt{name->idx} and
\texttt{idx->def}, i.e., first retrieving the index using \texttt{name->idx}
and then getting the definition using \texttt{idx->def}.
For example, the user interface

{\centering
  \texttt{(pl-major 'Josh)}

}
is macro-expanded to

{\centering
\texttt{(cdr (assv idx->def (cdr (assv name->idx 'pl-major))) 'Josh)}.

}

When an \texttt{assume-rel} operator is invoked, the two containers are extended
again: (1) a new index is created; (2) \texttt{idx->def} contains the pair of
the new index and the extended function; and (3) \texttt{name->idx} now has
a new pair of the definition name and the new index, this new pair shadows the
previous one.

For example, let's use \texttt{t$_1$} for the \texttt{taken} definition
that knows Josh has taken \texttt{B521} and \texttt{B522},
use \texttt{t$_2$} for the extended \texttt{taken}
(where we assume-rel Josh has taken \texttt{B523}), and use \texttt{p} for
the definition of \texttt{pl-major} .
With \texttt{taken} and \texttt{pl-major} first defined,
\texttt{name->idx} is \texttt{((pl-major . 2) (taken . 1))}
and \texttt{idx->body} is \mbox{\texttt{((2 . p) (1 . t$_1$))}}.
Then, after assuming \texttt{(taken 'Josh q)}, the query \texttt{(pl-major 'Josh)}
runs in an updated environment where 
\texttt{name->idx} is \texttt{((taken . 3) (pl-major . 2) (taken . 1) )}
and \texttt{idx->body} is \mbox{\texttt{((3 . $t_2$) (2 . p) (1 . t$_1$))}}.
The more recent pair in \texttt{name->idx} shadows the previous one. And therefore,
when \texttt{taken} is invoked, we use \texttt{t$_2$}.

Many interesting examples only make hypothesis on atomic formulas. And thus we
provide the \texttt{assume} operator that is a shorter version of the
\texttt{assume-rel} operator. Instead of any D formula, the \texttt{assume}
operator can only take an atomic hypothesis.

As an example, we define the \texttt{eq} relation to be reflexive, transitive,
and symmetric as follows.
\begin{lstlisting}
  (defrel (eq x y)
    (cond$^e$
      [(== x y)]
      [(fresh (z)
         (eq x z)
         (eq z y))]
      [(eq y x)]))
\end{lstlisting}
Obviously \texttt{apple} and \texttt{orange} are by no means \texttt{eq}. 
In fact, the following query does not terminate in a naive $\mu$Kanren
implementation because the third cond$^e$ line is very recursive.
\begin{lstlisting}
  > (run 1 q
      (eq 'apple 'orange))
\end{lstlisting}

\clearpage

Using \texttt{assume}, we may temporarily extend the definition of
\texttt{eq} as follows.
\begin{lstlisting}
  > (run 5 q
      (assume (eq 'orange 'apple)
        (assume (eq 'orange 'dog)  
          (eq 'orange q))))
  '(dog apple orange orange dog)
\end{lstlisting}

Because $\lambda$Kanren runs backward, as in the following,
the hypothesis can be inferred as well.
\begin{lstlisting}
  > (run 1 q
      (assume (eq 'orange q)
        (eq 'apple 'orange))))
  '(apple)
\end{lstlisting}

\section{Forall-quantification}
This section introduces the \texttt{all} operator ($\forall x G$) that takes
a list of symbols and a goal. These symbols are used to create special
variables that are virtually constants (eigenvariables).

Continuing with \texttt{taken} and \texttt{pl-major},
we create a random person \texttt{x} using the \texttt{all} operator.
\begin{lstlisting}
> (run 1 q
    (all (x)
      (assume-rel (taken x 'B521)
        (assume-rel (taken x 'B522)
          (assume-rel (taken x 'B523)
            (pl-major x))))))
'(_0)
\end{lstlisting}

Like the \texttt{fresh} operator, the \texttt{all} operator creates a new
variable in the scope. Unlike the \texttt{fresh} operator, the \texttt{all}
operator effectively creates a constant. This semantics is similar to the
proof technique of a for-all goal in first-order logic: to prove
$\forall x. P$, we fix a constant $x$ and then prove $P$.

Consider the next example that synthesizes the identity function using the
\texttt{all} operator. 
\begin{lstlisting}
> (run 1 f
    (all (x)
      (== x (app f x))))
'((tie (_0) _0))
\end{lstlisting}

The implementation of the \texttt{all} operator follows that of the
\texttt{fresh} operator, except that the created variable is a constant.
In our implementation, we create an \texttt{all} variable as a free
binding variable. Thus, the \texttt{all} variable cannot be unified
with anything but itself.


\section{conclusion}
$\lambda$Kanren is based on higher-order hereditary Harrop formulas.
It extends $\mu$Kanren with four operators, \texttt{tie},
\texttt{app}, \texttt{assume-rel}, and \texttt{all}. In addition, unification
(\texttt{==}) identifies $\alpha\beta$-equivalence between the binding
operators.

Our implementation of $\lambda$Kanren is written in Racket by adding
about 40 lines to $\mu$Kanren. Overall, we appreciate the simplicity
provided by the shallow embedding techniques.

\bibliographystyle{plainnat}
\bibliography{main}

\end{document}
\endinput
%%
%% End of file `sample-acmlarge.tex'.
